# JPA - MultipleBagFetchException

JPA의 N+1 문제에 대한 해결책으로 Fetch Join을 사용하다보면 자주 만하는 문제가 있다.

바로 `MultipleBagFetchException` 이다.

이 문제는 2개 이상의 OneToMany 자식 테이블에 Fetch Join을 했을 때 발생한다.

> ex1) 엔티티 A, B, C가 존재하고 A:B=1:N 관계이고 B:C=1:N 관계일때, 테이블 A를 기준으로 B와 B.C를 Fetch Join 할때 발생한다.
> ex2) 엔티티 A, B, C가 존재하고 A:B=1:N 관계이고 A:C=1:N 관계일때, 테이블 A를 기준으로 B와 C를 Fetch Join 할때 발생한다.

**OneToOne, ManyToOne과 같이 단일 관계의 자식 테이블에는 Fetch Join을 써도 된다.**

이 문제에 대한 해결책으로 보통 2가지를 언급하는데 다음과 같다.

- 자식 테이블 하나에만 Fetch Join을 걸고 나머지는 Lazy Loading으로 조회
- 모든 자식 테이블을 다 Lazy Loading으로 조회

하지만 이럴 경우 성능은 떨어지게 되어있다. 그럼 성능까지 해결하는 방법은 무엇이 존재할까?

일단 JPA에서 Fetch Join의 조건은 다음과 같다.

- `~ToOne`은 **몇개든** 사용이 가능하다.
- `~ToMany`는 **한개만** 사용이 가능하다.

이제는 해결책을 알아보자.

## Hibernate default_batch_fetch_size

해결책은 하이버네이트의 `default_batch_fetch_size` 옵션에 있다.

N+1 문제란 결국 부모 엔티티와 연관관계가 있는 자식 엔티티들의 조회 쿼리가 문제이다. -> 부모 엔티티의 Key 하나하나를 자식 엔티티 조회로 사용하기 때문인데

그렇다면 1개씩 사용되는 조건문을 in절로 묶어서 조회하면 어떨까?

바로 hibernate.default_batch_fetch_size 옵션이 이 동작을 하게끔 해준다.

이 옵션은 지정된 수만큼 in절에 부모 Key를 사용하게 해준다.